# file opened: src/main.asm
  1   0000              ; FILE   : main.asm
  2   0000              ; PROJECT: Dice Roller
  3   0000              ; BRIEF  : Handles the main program loop
  4   0000              ; AUTHOR : leifs
  5   0000              ; TARGET : z80-ceres8-none, SjASMPlus
  6   0000
  7   0000                  ORG $0000
  8   0000
  9   0000 31 FF FF     start       LD	    SP, $FFFF           ; Set stack to top of RAM
 10   0003 CD 09 00                 CALL    lcdInit
 11   0006
 12   0006 C3 06 00     .loop       JP	    .loop
 13   0009
 14   0009
 15   0009                  ; Includes put at the end b/c SjASM doesn't support linking
 16   0009                  INCLUDE "lcd.asm"
# file opened: src/lcd.asm
  1+  0009              ; FILE   : lcd.asm
  2+  0009              ; PROJECT: Dice Roller
  3+  0009              ; BRIEF  : Implements functions to control the LCD
  4+  0009              ; AUTHOR : leifs
  5+  0009              ; TARGET : z80-ceres8-none, SjASMPlus
  6+  0009
  7+  0009                  IFNDEF LCD_ASM_
  8+  0009                  DEFINE LCD_ASM_
  9+  0009
 10+  0009              LCD_REG     EQU     $00
 11+  0009              LCD_RAM     EQU     $01
 12+  0009
 13+  0009              ; FUNCTION: lcdInit
 14+  0009              ; BRIEF   : Initializes the LCD
 15+  0009              ; PARAMS  : C - Cursor Off/On (0/1)
 16+  0009              ; RETURN  : None
 17+  0009              ; CLOBBERS: A
 18+  0009 C5           lcdInit     PUSH    BC                  ; Store C parameter for later
 19+  000A
 20+  000A 0E 08                    LD      C, $08              ; Wait >15ms for LCD reset sequence
 21+  000C 06 0C        .waitloop   LD      B, $0C
 22+  000E 10 FE                    DJNZ    $
 23+  0010 0D                       DEC     C
 24+  0011 20 F9                    JR      NZ, .waitloop
 25+  0013
 26+  0013 3E 38                    LD      A, %00111000        ; Set: 8-bit, 16x2 chars, 5x8 font
 27+  0015 D3 00                    OUT     (LCD_REG), A
 28+  0017
 29+  0017 06 0C                    LD      B, 12               ; Wait >37us before next command
 30+  0019 10 FE                    DJNZ    $
 31+  001B
 32+  001B D3 00                    OUT     (LCD_REG), A        ; Repeat to comply with datasheet
 33+  001D 06 0C                    LD      B, 12
 34+  001F 10 FE                    DJNZ    $
 35+  0021
 36+  0021 3E 0C                    LD      A, %00001100        ; Display on, cursor off
 37+  0023
 38+  0023 C1                       POP     BC                  ; Restore C for parameter
 39+  0024 CB 09                    RRC     C                   ; Check bit 0 instead of comparing to 1
 40+  0026 30 02                    JR      NC, .nocursor       ; If C = 1, turn cursor on
 41+  0028 C6 03                    ADD     A, %00000011
 42+  002A
 43+  002A D3 00        .nocursor   OUT     (LCD_REG), A
 44+  002C CD 61 00                 CALL    lcdWait
 45+  002F
 46+  002F 3E 01                    LD      A, %00000001        ; Clear Display
 47+  0031 D3 00                    OUT     (LCD_REG), A
 48+  0033 CD 61 00                 CALL    lcdWait
 49+  0036
 50+  0036 3E 06                    LD      A, %00000110        ; Entry Mode: Increment, no shift
 51+  0038 D3 00                    OUT     (LCD_REG), A
 52+  003A CD 61 00                 CALL    lcdWait
 53+  003D
 54+  003D C9                       RET
 55+  003E
 56+  003E
 57+  003E
 58+  003E              ; FUNCTION: lcdClear
 59+  003E              ; BRIEF   : Clears the LCD
 60+  003E              ; PARAMS  : None
 61+  003E              ; RETURN  : None
 62+  003E              ; CLOBBERS: A
 63+  003E 3E 01        lcdClear    LD      A, %00000001
 64+  0040 D3 00                    OUT     (LCD_REG), A
 65+  0042 CD 61 00                 CALL    lcdWait
 66+  0045 C9                       RET
 67+  0046
 68+  0046
 69+  0046
 70+  0046              ; FUNCTION: lcdRethome
 71+  0046              ; BRIEF   : Returns the cursor to 0,0
 72+  0046              ; PARAMS  : None
 73+  0046              ; RETURN  : None
 74+  0046              ; CLOBBERS: A
 75+  0046 3E 02        lcdRethome  LD      A, %00000010
 76+  0048 D3 00                    OUT     (LCD_REG), A
 77+  004A CD 61 00                 CALL    lcdWait
 78+  004D C9                       RET
 79+  004E
 80+  004E
 81+  004E
 82+  004E              ; FUNCTION: lcdMovcur
 83+  004E              ; BRIEF   : Moves the cursor to a new position
 84+  004E              ; PARAMS  : B - Column: 0-15, C - Row 0-1
 85+  004E              ; RETURN  : None
 86+  004E              ; CLOBBERS: A, B, C
 87+  004E 47           lcdMovcur   LD      B, A                ; Load column
 88+  004F E6 0F                    AND     $0F                 ; Keep within screen bounds
 89+  0051
 90+  0051 CB 09                    RRC     C                   ; Check if on second row
 91+  0053 30 02                    JR      NC, .firstrow
 92+  0055 C6 40                    ADD     A, $40              ; Second row starts at $40
 93+  0057
 94+  0057 B7 F6 80     .firstrow   OR      A, %10000000        ; Set bit 7 to format as LCD instruction
 95+  005A D3 00                    OUT     (LCD_REG), A
 96+  005C
 97+  005C 06 0C                    LD      B, 12               ; Busy wait, since polling resets cursor
 98+  005E 10 FE                    DJNZ    $
 99+  0060
100+  0060 C9                       RET
101+  0061
102+  0061
103+  0061
104+  0061              ; FUNCTION: lcdWait
105+  0061              ; BRIEF   : Waits until LCD is not busy
106+  0061              ; PARAMS  : None
107+  0061              ; RETURN  : None
108+  0061              ; CLOBBERS: A
109+  0061 C5           lcdWait     PUSH    BC
110+  0062
111+  0062 06 0C                    LD      B, 12               ; Wait >80us before polling again
112+  0064 10 FE                    DJNZ    $
113+  0066
114+  0066 DB 00                    IN      A, (LCD_REG)        ; Read LCD Status, busy flag is bit 7
115+  0068 07                       RLCA
116+  0069 38 F6                    JR      C, lcdWait
117+  006B
118+  006B C1                       POP     BC
119+  006C C9                       RET
120+  006D
121+  006D                  ENDIF
122+  006D
# file closed: src/lcd.asm
 17   006D                  INCLUDE "menu.asm"
# file opened: src/menu.asm
  1+  006D              ; FILE   : menu.asm
  2+  006D              ; PROJECT: Dice Roller
  3+  006D              ; BRIEF  : Provides menu functions and handlers
  4+  006D              ; AUTHOR : leifs
  5+  006D              ; TARGET : z80-ceres8-none, SjASMPlus
  6+  006D
  7+  006D                  IFNDEF MENU_ASM_
  8+  006D                  DEFINE MENU_ASM_
  9+  006D
 10+  006D              ; FUNCTION: loadMenu
 11+  006D              ; BRIEF   : Resets the program state and loads a new menu
 12+  006D              ; PARAMS  : HL - Pointer to Menu object
 13+  006D              ; RETURN  : None
 14+  006D C9           loadMenu    RET
 15+  006E
 16+  006E
 17+  006E              ; FUNCTION: mhSplash
 18+  006E              ; BRIEF   : Menu handler for the Splash menu
 19+  006E              ; PARAMS  : None
 20+  006E              ; RETURN  : None
 21+  006E C9           mhSplash    RET
 22+  006F
 23+  006F
 24+  006F
 25+  006F              ; FUNCTION: mhDieSelect
 26+  006F              ; BRIEF   : Menu handler for the Die Select menu
 27+  006F              ; PARAMS  : None
 28+  006F              ; RETURN  : None
 29+  006F C9           mhDieSelect RET
 30+  0070
 31+  0070
 32+  0070
 33+  0070              ; FUNCTION: mhDieCount
 34+  0070              ; BRIEF   : Menu handler for the Die Count menu
 35+  0070              ; PARAMS  : None
 36+  0070              ; RETURN  : None
 37+  0070 C9           mhDieCount  RET
 38+  0071
 39+  0071
 40+  0071
 41+  0071              ; FUNCTION: mhDieMod
 42+  0071              ; BRIEF   : Menu handler for the Die Modifier menu
 43+  0071              ; PARAMS  : None
 44+  0071              ; RETURN  : None
 45+  0071 C9           mhDieMod    RET
 46+  0072
 47+  0072
 48+  0072
 49+  0072              ; FUNCTION: mhTotal
 50+  0072              ; BRIEF   : Menu handler for the Total menu
 51+  0072              ; PARAMS  : None
 52+  0072              ; RETURN  : None
 53+  0072 C9           mhTotal     RET
 54+  0073
 55+  0073
 56+  0073
 57+  0073              ; FUNCTION: mhAnim
 58+  0073              ; BRIEF   : Menu handler for the Animation menu
 59+  0073              ; PARAMS  : None
 60+  0073              ; RETURN  : None
 61+  0073 C9           mhAnim      RET
 62+  0074
 63+  0074                  ENDIF
 64+  0074
# file closed: src/menu.asm
 18   0074                  INCLUDE "consts.asm"
# file opened: src/consts.asm
  1+  0074              ; FILE   : consts.asm
  2+  0074              ; PROJECT: Dice Roller
  3+  0074              ; BRIEF  : Defines several data constants
  4+  0074              ; AUTHOR : leifs
  5+  0074              ; TARGET : z80-ceres8-none, SjASMPlus
  6+  0074
  7+  0074                  IFNDEF CONSTS_ASM_
  8+  0074                  DEFINE CONSTS_ASM_
  9+  0074
 10+  0074              ; *** CHARS ***
 11+  0074              U_ARROW     EQU     $5C
 12+  0074              D_ARROW     EQU     $6C
 13+  0074              L_ARROW     EQU     $7C
 14+  0074              R_ARROW     EQU     $8C
 15+  0074
 16+  0074              ; *** STRUCTS ***
 17+  0074
 18+  0074                  ; MACRO: Menu
 19+  0074                  ; BRIEF: Data structure for a Menu object
 20+  0074                  ; PARAM: Handler, Address to menu handler function
 21+  0074                  ; PARAM: TopStr, Pascal-style string to display on first row
 22+  0074                  ; PARAM: BotStr, Pascal-style string of entries to display on second row.
 23+  0074                  ; PARAM: EntryCount, Number of entries in menu. Can be 0.
 24+  0074                  ; PARAM: EntryPos, Array of positions of each entry in the menu.
 25+  0074                  MACRO Menu Handler, TopStr, BotStr, EntryCount, EntryPos
 26+  0074 ~                    WORD Handler
 27+  0074 ~                    BYTE TopStr
 28+  0074 ~                    BYTE BotStr
 29+  0074 ~                    BYTE EntryCount
 30+  0074 ~                    BYTE EntryPos
 31+  0074                  ENDM
 32+  0074
 33+  0074              ; *** MENUS ***
 34+  0074
 35+  0074              ; Splash screen at system startup
 40+  0074              mSplash:    Menu    mhSplash,                    <15,"DnD Dice Roller">,                    <16,"By Leif :)     ",D_ARROW>,                    0,                    0
 40+  0074 6E 00       >        WORD mhSplash
 40+  0076 0F 44 6E 44 >        BYTE 15,"DnD Dice Roller"
 40+  007A 20 44 69 63 >
 40+  007E 65 20 52 6F >
 40+  0082 6C 6C 65 72 >
 40+  0086 10 42 79 20 >        BYTE 16,"By Leif :)     ",D_ARROW
 40+  008A 4C 65 69 66 >
 40+  008E 20 3A 29 20 >
 40+  0092 20 20 20 20 >
 40+  0096 6C          >
 40+  0097 00          >        BYTE 0
 40+  0098 00          >        BYTE 0
 41+  0099
 42+  0099              ; Select die to roll
 47+  0099              mDieSelect: Menu    mhDieSelect,                    <16,"Die Select:    ",D_ARROW>,                    <31,"D4 D6 D8 D10 D12 D20 D100 Custom">,                    8,                    <0,3,6,9,13,17,21,26>
 47+  0099 6F 00       >        WORD mhDieSelect
 47+  009B 10 44 69 65 >        BYTE 16,"Die Select:    ",D_ARROW
 47+  009F 20 53 65 6C >
 47+  00A3 65 63 74 3A >
 47+  00A7 20 20 20 20 >
 47+  00AB 6C          >
 47+  00AC 1F 44 34 20 >        BYTE 31,"D4 D6 D8 D10 D12 D20 D100 Custom"
 47+  00B0 44 36 20 44 >
 47+  00B4 38 20 44 31 >
 47+  00B8 30 20 44 31 >
 47+  00BC 32 20 44 32 >
 47+  00C0 30 20 44 31 >
 47+  00C4 30 30 20 43 >
 47+  00C8 75 73 74 6F >
 47+  00CC 6D          >
 47+  00CD 08          >        BYTE 8
 47+  00CE 00 03 06 09 >        BYTE 0,3,6,9,13,17,21,26
 47+  00D2 0D 11 15 1A >
 48+  00D6
 49+  00D6              ; Select number of dice to roll
 54+  00D6              mDieCount:  Menu    mhDieCount,                    <16,"Num. Dice:   ",L_ARROW,' ',R_ARROW>,                    "\0",                    1,                    0
 54+  00D6 70 00       >        WORD mhDieCount
 54+  00D8 10 4E 75 6D >        BYTE 16,"Num. Dice:   ",L_ARROW,' ',R_ARROW
 54+  00DC 2E 20 44 69 >
 54+  00E0 63 65 3A 20 >
 54+  00E4 20 20 7C 20 >
 54+  00E8 8C          >
 54+  00E9 00          >        BYTE "\0"
 54+  00EA 01          >        BYTE 1
 54+  00EB 00          >        BYTE 0
 55+  00EC
 56+  00EC              ; Die modifier, only displayed when rolling one die
 61+  00EC              mDieMod:    Menu    mhDieMod,                    <16,"Roll As:       ",D_ARROW>,                    <11,"Reg Adv Dis">,                    3,                    <0,4,8>
 61+  00EC 71 00       >        WORD mhDieMod
 61+  00EE 10 52 6F 6C >        BYTE 16,"Roll As:       ",D_ARROW
 61+  00F2 6C 20 41 73 >
 61+  00F6 3A 20 20 20 >
 61+  00FA 20 20 20 20 >
 61+  00FE 6C          >
 61+  00FF 0B 52 65 67 >        BYTE 11,"Reg Adv Dis"
 61+  0103 20 41 64 76 >
 61+  0107 20 44 69 73 >
 61+  010B 03          >        BYTE 3
 61+  010C 00 04 08    >        BYTE 0,4,8
 62+  010F
 63+  010F              ; Display total rolled
 68+  010F              mTotal:     Menu    mhTotal,                    <13,"You Rolled...">,                    "\0",                    0,                    0
 68+  010F 72 00       >        WORD mhTotal
 68+  0111 0D 59 6F 75 >        BYTE 13,"You Rolled..."
 68+  0115 20 52 6F 6C >
 68+  0119 6C 65 64 2E >
 68+  011D 2E 2E       >
 68+  011F 00          >        BYTE "\0"
 68+  0120 00          >        BYTE 0
 68+  0121 00          >        BYTE 0
 69+  0122
 70+  0122              ; Rolling animation. May be used if I feel like it.
 75+  0122              mAnim:      Menu    mAnim,                    "\0",                    "\0",                    0,                    0
 75+  0122 22 01       >        WORD mAnim
 75+  0124 00          >        BYTE "\0"
 75+  0125 00          >        BYTE "\0"
 75+  0126 00          >        BYTE 0
 75+  0127 00          >        BYTE 0
 76+  0128                  ENDIF
# file closed: src/consts.asm
 19   0128                  INCLUDE "variables.asm"
# file opened: src/variables.asm
  1+  0128              ; FILE   : variables.asm
  2+  0128              ; PROJECT: Dice Roller
  3+  0128              ; BRIEF  : Reserves space for RAM variables
  4+  0128              ; AUTHOR : leifs
  5+  0128              ; TARGET : z80-ceres8-none, SjASMPlus
  6+  0128
  7+  0128                  IFNDEF VARIABLES_ASM_
  8+  0128                  DEFINE VARIABLES_ASM_
  9+  0128
 10+  0128                  ORG $4000
 11+  4000
 12+  4000                  STRUCT ButtonState
 13+  4000 ~            LastState           BYTE                ; The previous button state
 14+  4000 ~            CurrentState        BYTE                ; The current button state
 15+  4000 ~            ButtonSummary       BYTE                ; Bit 0, isPressed, Bit 1, hasChanged
 16+  4000                  ENDS
 17+  4000
 18+  4000                  STRUCT DiceState
 19+  4000 ~            DieSides            BYTE                ; Highest number a die can roll
 20+  4000 ~            NumDice             BYTE                ; The number of dice to roll
 21+  4000 ~            Modifier            BYTE                ; Roll at advantage/disadvantage
 22+  4000 ~            Total               WORD                ; Final dice roll
 23+  4000                  ENDS
 24+  4000
 25+  4000                  STRUCT ProgramState
 26+  4000 ~            CursorPos   BYTE
 27+  4000 ~            Menu        WORD
 28+  4000                  ENDS
 29+  4000
 30+  4000 00 00 00 00  diceState DiceState
 30+  4004 00
 31+  4005
 32+  4005 00 00 00     buttonState ButtonState
 33+  4008
 34+  4008 00 00 00     programState ProgramState
 35+  400B
 36+  400B                  ENDIF
# file closed: src/variables.asm
 20   400B
# file closed: src/main.asm
# file opened: src/lcd.asm
  1   400B              ; FILE   : lcd.asm
  2   400B              ; PROJECT: Dice Roller
  3   400B              ; BRIEF  : Implements functions to control the LCD
  4   400B              ; AUTHOR : leifs
  5   400B              ; TARGET : z80-ceres8-none, SjASMPlus
  6   400B
  7   400B                  IFNDEF LCD_ASM_
  8   400B ~                DEFINE LCD_ASM_
  9   400B ~
 10   400B ~            LCD_REG     EQU     $00
 11   400B ~            LCD_RAM     EQU     $01
 12   400B ~
 13   400B ~            ; FUNCTION: lcdInit
 14   400B ~            ; BRIEF   : Initializes the LCD
 15   400B ~            ; PARAMS  : C - Cursor Off/On (0/1)
 16   400B ~            ; RETURN  : None
 17   400B ~            ; CLOBBERS: A
 18   400B ~            lcdInit     PUSH    BC                  ; Store C parameter for later
 19   400B ~
 20   400B ~                        LD      C, $08              ; Wait >15ms for LCD reset sequence
 21   400B ~            .waitloop   LD      B, $0C
 22   400B ~                        DJNZ    $
 23   400B ~                        DEC     C
 24   400B ~                        JR      NZ, .waitloop
 25   400B ~
 26   400B ~                        LD      A, %00111000        ; Set: 8-bit, 16x2 chars, 5x8 font
 27   400B ~                        OUT     (LCD_REG), A
 28   400B ~
 29   400B ~                        LD      B, 12               ; Wait >37us before next command
 30   400B ~                        DJNZ    $
 31   400B ~
 32   400B ~                        OUT     (LCD_REG), A        ; Repeat to comply with datasheet
 33   400B ~                        LD      B, 12
 34   400B ~                        DJNZ    $
 35   400B ~
 36   400B ~                        LD      A, %00001100        ; Display on, cursor off
 37   400B ~
 38   400B ~                        POP     BC                  ; Restore C for parameter
 39   400B ~                        RRC     C                   ; Check bit 0 instead of comparing to 1
 40   400B ~                        JR      NC, .nocursor       ; If C = 1, turn cursor on
 41   400B ~                        ADD     A, %00000011
 42   400B ~
 43   400B ~            .nocursor   OUT     (LCD_REG), A
 44   400B ~                        CALL    lcdWait
 45   400B ~
 46   400B ~                        LD      A, %00000001        ; Clear Display
 47   400B ~                        OUT     (LCD_REG), A
 48   400B ~                        CALL    lcdWait
 49   400B ~
 50   400B ~                        LD      A, %00000110        ; Entry Mode: Increment, no shift
 51   400B ~                        OUT     (LCD_REG), A
 52   400B ~                        CALL    lcdWait
 53   400B ~
 54   400B ~                        RET
 55   400B ~
 56   400B ~
 57   400B ~
 58   400B ~            ; FUNCTION: lcdClear
 59   400B ~            ; BRIEF   : Clears the LCD
 60   400B ~            ; PARAMS  : None
 61   400B ~            ; RETURN  : None
 62   400B ~            ; CLOBBERS: A
 63   400B ~            lcdClear    LD      A, %00000001
 64   400B ~                        OUT     (LCD_REG), A
 65   400B ~                        CALL    lcdWait
 66   400B ~                        RET
 67   400B ~
 68   400B ~
 69   400B ~
 70   400B ~            ; FUNCTION: lcdRethome
 71   400B ~            ; BRIEF   : Returns the cursor to 0,0
 72   400B ~            ; PARAMS  : None
 73   400B ~            ; RETURN  : None
 74   400B ~            ; CLOBBERS: A
 75   400B ~            lcdRethome  LD      A, %00000010
 76   400B ~                        OUT     (LCD_REG), A
 77   400B ~                        CALL    lcdWait
 78   400B ~                        RET
 79   400B ~
 80   400B ~
 81   400B ~
 82   400B ~            ; FUNCTION: lcdMovcur
 83   400B ~            ; BRIEF   : Moves the cursor to a new position
 84   400B ~            ; PARAMS  : B - Column: 0-15, C - Row 0-1
 85   400B ~            ; RETURN  : None
 86   400B ~            ; CLOBBERS: A, B, C
 87   400B ~            lcdMovcur   LD      B, A                ; Load column
 88   400B ~                        AND     $0F                 ; Keep within screen bounds
 89   400B ~
 90   400B ~                        RRC     C                   ; Check if on second row
 91   400B ~                        JR      NC, .firstrow
 92   400B ~                        ADD     A, $40              ; Second row starts at $40
 93   400B ~
 94   400B ~            .firstrow   OR      A, %10000000        ; Set bit 7 to format as LCD instruction
 95   400B ~                        OUT     (LCD_REG), A
 96   400B ~
 97   400B ~                        LD      B, 12               ; Busy wait, since polling resets cursor
 98   400B ~                        DJNZ    $
 99   400B ~
100   400B ~                        RET
101   400B ~
102   400B ~
103   400B ~
104   400B ~            ; FUNCTION: lcdWait
105   400B ~            ; BRIEF   : Waits until LCD is not busy
106   400B ~            ; PARAMS  : None
107   400B ~            ; RETURN  : None
108   400B ~            ; CLOBBERS: A
109   400B ~            lcdWait     PUSH    BC
110   400B ~
111   400B ~                        LD      B, 12               ; Wait >80us before polling again
112   400B ~                        DJNZ    $
113   400B ~
114   400B ~                        IN      A, (LCD_REG)        ; Read LCD Status, busy flag is bit 7
115   400B ~                        RLCA
116   400B ~                        JR      C, lcdWait
117   400B ~
118   400B ~                        POP     BC
119   400B ~                        RET
120   400B ~
121   400B                  ENDIF
122   400B
# file closed: src/lcd.asm
# file opened: src/variables.asm
  1   400B              ; FILE   : variables.asm
  2   400B              ; PROJECT: Dice Roller
  3   400B              ; BRIEF  : Reserves space for RAM variables
  4   400B              ; AUTHOR : leifs
  5   400B              ; TARGET : z80-ceres8-none, SjASMPlus
  6   400B
  7   400B                  IFNDEF VARIABLES_ASM_
  8   400B ~                DEFINE VARIABLES_ASM_
  9   400B ~
 10   400B ~                ORG $4000
 11   400B ~
 12   400B ~                STRUCT ButtonState
 13   400B ~            LastState           BYTE                ; The previous button state
 14   400B ~            CurrentState        BYTE                ; The current button state
 15   400B ~            ButtonSummary       BYTE                ; Bit 0, isPressed, Bit 1, hasChanged
 16   400B ~                ENDS
 17   400B ~
 18   400B ~                STRUCT DiceState
 19   400B ~            DieSides            BYTE                ; Highest number a die can roll
 20   400B ~            NumDice             BYTE                ; The number of dice to roll
 21   400B ~            Modifier            BYTE                ; Roll at advantage/disadvantage
 22   400B ~            Total               WORD                ; Final dice roll
 23   400B ~                ENDS
 24   400B ~
 25   400B ~                STRUCT ProgramState
 26   400B ~            CursorPos   BYTE
 27   400B ~            Menu        WORD
 28   400B ~                ENDS
 29   400B ~
 30   400B ~            diceState DiceState
 31   400B ~
 32   400B ~            buttonState ButtonState
 33   400B ~
 34   400B ~            programState ProgramState
 35   400B ~
 36   400B                  ENDIF
# file closed: src/variables.asm
# file opened: src/menu.asm
  1   400B              ; FILE   : menu.asm
  2   400B              ; PROJECT: Dice Roller
  3   400B              ; BRIEF  : Provides menu functions and handlers
  4   400B              ; AUTHOR : leifs
  5   400B              ; TARGET : z80-ceres8-none, SjASMPlus
  6   400B
  7   400B                  IFNDEF MENU_ASM_
  8   400B ~                DEFINE MENU_ASM_
  9   400B ~
 10   400B ~            ; FUNCTION: loadMenu
 11   400B ~            ; BRIEF   : Resets the program state and loads a new menu
 12   400B ~            ; PARAMS  : HL - Pointer to Menu object
 13   400B ~            ; RETURN  : None
 14   400B ~            loadMenu    RET
 15   400B ~
 16   400B ~
 17   400B ~            ; FUNCTION: mhSplash
 18   400B ~            ; BRIEF   : Menu handler for the Splash menu
 19   400B ~            ; PARAMS  : None
 20   400B ~            ; RETURN  : None
 21   400B ~            mhSplash    RET
 22   400B ~
 23   400B ~
 24   400B ~
 25   400B ~            ; FUNCTION: mhDieSelect
 26   400B ~            ; BRIEF   : Menu handler for the Die Select menu
 27   400B ~            ; PARAMS  : None
 28   400B ~            ; RETURN  : None
 29   400B ~            mhDieSelect RET
 30   400B ~
 31   400B ~
 32   400B ~
 33   400B ~            ; FUNCTION: mhDieCount
 34   400B ~            ; BRIEF   : Menu handler for the Die Count menu
 35   400B ~            ; PARAMS  : None
 36   400B ~            ; RETURN  : None
 37   400B ~            mhDieCount  RET
 38   400B ~
 39   400B ~
 40   400B ~
 41   400B ~            ; FUNCTION: mhDieMod
 42   400B ~            ; BRIEF   : Menu handler for the Die Modifier menu
 43   400B ~            ; PARAMS  : None
 44   400B ~            ; RETURN  : None
 45   400B ~            mhDieMod    RET
 46   400B ~
 47   400B ~
 48   400B ~
 49   400B ~            ; FUNCTION: mhTotal
 50   400B ~            ; BRIEF   : Menu handler for the Total menu
 51   400B ~            ; PARAMS  : None
 52   400B ~            ; RETURN  : None
 53   400B ~            mhTotal     RET
 54   400B ~
 55   400B ~
 56   400B ~
 57   400B ~            ; FUNCTION: mhAnim
 58   400B ~            ; BRIEF   : Menu handler for the Animation menu
 59   400B ~            ; PARAMS  : None
 60   400B ~            ; RETURN  : None
 61   400B ~            mhAnim      RET
 62   400B ~
 63   400B                  ENDIF
 64   400B
# file closed: src/menu.asm
